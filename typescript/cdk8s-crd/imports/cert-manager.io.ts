// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * A Certificate resource should be created to ensure an up to date and signed
X.509 certificate is stored in the Kubernetes Secret resource named in `spec.secretName`.

The stored certificate will be renewed before it expires (as configured by `spec.renewBefore`).
 *
 * @schema Certificate
 */
export class Certificate extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Certificate"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'cert-manager.io/v1',
    kind: 'Certificate',
  }

  /**
   * Renders a Kubernetes manifest for "Certificate".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CertificateProps = {}): any {
    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(props),
    };
  }

  /**
   * Defines a "Certificate" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CertificateProps = {}) {
    super(scope, id, {
      ...Certificate.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Certificate.GVK,
      ...toJson_CertificateProps(resolved),
    };
  }
}

/**
 * A Certificate resource should be created to ensure an up to date and signed
 * X.509 certificate is stored in the Kubernetes Secret resource named in `spec.secretName`.
 *
 * The stored certificate will be renewed before it expires (as configured by `spec.renewBefore`).
 *
 * @schema Certificate
 */
export interface CertificateProps {
  /**
   * @schema Certificate#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Specification of the desired state of the Certificate resource.
   * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
   *
   * @schema Certificate#spec
   */
  readonly spec?: CertificateSpec;

}

/**
 * Converts an object of type 'CertificateProps' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateProps(obj: CertificateProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CertificateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Specification of the desired state of the Certificate resource.
 * https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
 *
 * @schema CertificateSpec
 */
export interface CertificateSpec {
  /**
   * Defines extra output formats of the private key and signed certificate chain
   * to be written to this Certificate's target Secret.
   *
   * This is a Beta Feature enabled by default. It can be disabled with the
   * `--feature-gates=AdditionalCertificateOutputFormats=false` option set on both
   * the controller and webhook components.
   *
   * @schema CertificateSpec#additionalOutputFormats
   */
  readonly additionalOutputFormats?: CertificateSpecAdditionalOutputFormats[];

  /**
   * Requested common name X509 certificate subject attribute.
   * More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6
   * NOTE: TLS clients will ignore this value when any subject alternative name is
   * set (see https://tools.ietf.org/html/rfc6125#section-6.4.4).
   *
   * Should have a length of 64 characters or fewer to avoid generating invalid CSRs.
   * Cannot be set if the `literalSubject` field is set.
   *
   * @schema CertificateSpec#commonName
   */
  readonly commonName?: string;

  /**
   * Requested DNS subject alternative names.
   *
   * @schema CertificateSpec#dnsNames
   */
  readonly dnsNames?: string[];

  /**
   * Requested 'duration' (i.e. lifetime) of the Certificate. Note that the
   * issuer may choose to ignore the requested duration, just like any other
   * requested attribute.
   *
   * If unset, this defaults to 90 days.
   * Minimum accepted duration is 1 hour.
   * Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration.
   *
   * @schema CertificateSpec#duration
   */
  readonly duration?: string;

  /**
   * Requested email subject alternative names.
   *
   * @schema CertificateSpec#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * Whether the KeyUsage and ExtKeyUsage extensions should be set in the encoded CSR.
   *
   * This option defaults to true, and should only be disabled if the target
   * issuer does not support CSRs with these X509 KeyUsage/ ExtKeyUsage extensions.
   *
   * @schema CertificateSpec#encodeUsagesInRequest
   */
  readonly encodeUsagesInRequest?: boolean;

  /**
   * Requested IP address subject alternative names.
   *
   * @schema CertificateSpec#ipAddresses
   */
  readonly ipAddresses?: string[];

  /**
   * Requested basic constraints isCA value.
   * The isCA value is used to set the `isCA` field on the created CertificateRequest
   * resources. Note that the issuer may choose to ignore the requested isCA value, just
   * like any other requested attribute.
   *
   * If true, this will automatically add the `cert sign` usage to the list
   * of requested `usages`.
   *
   * @schema CertificateSpec#isCA
   */
  readonly isCa?: boolean;

  /**
   * Reference to the issuer responsible for issuing the certificate.
   * If the issuer is namespace-scoped, it must be in the same namespace
   * as the Certificate. If the issuer is cluster-scoped, it can be used
   * from any namespace.
   *
   * The `name` field of the reference must always be specified.
   *
   * @schema CertificateSpec#issuerRef
   */
  readonly issuerRef: CertificateSpecIssuerRef;

  /**
   * Additional keystore output formats to be stored in the Certificate's Secret.
   *
   * @schema CertificateSpec#keystores
   */
  readonly keystores?: CertificateSpecKeystores;

  /**
   * Requested X.509 certificate subject, represented using the LDAP "String
   * Representation of a Distinguished Name" [1].
   * Important: the LDAP string format also specifies the order of the attributes
   * in the subject, this is important when issuing certs for LDAP authentication.
   * Example: `CN=foo,DC=corp,DC=example,DC=com`
   * More info [1]: https://datatracker.ietf.org/doc/html/rfc4514
   * More info: https://github.com/cert-manager/cert-manager/issues/3203
   * More info: https://github.com/cert-manager/cert-manager/issues/4424
   *
   * Cannot be set if the `subject` or `commonName` field is set.
   *
   * @schema CertificateSpec#literalSubject
   */
  readonly literalSubject?: string;

  /**
   * x.509 certificate NameConstraint extension which MUST NOT be used in a non-CA certificate.
   * More Info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10
   *
   * This is an Alpha Feature and is only enabled with the
   * `--feature-gates=NameConstraints=true` option set on both
   * the controller and webhook components.
   *
   * @schema CertificateSpec#nameConstraints
   */
  readonly nameConstraints?: CertificateSpecNameConstraints;

  /**
   * `otherNames` is an escape hatch for SAN that allows any type. We currently restrict the support to string like otherNames, cf RFC 5280 p 37
   * Any UTF8 String valued otherName can be passed with by setting the keys oid: x.x.x.x and UTF8Value: somevalue for `otherName`.
   * Most commonly this would be UPN set with oid: 1.3.6.1.4.1.311.20.2.3
   * You should ensure that any OID passed is valid for the UTF8String type as we do not explicitly validate this.
   *
   * @schema CertificateSpec#otherNames
   */
  readonly otherNames?: CertificateSpecOtherNames[];

  /**
   * Private key options. These include the key algorithm and size, the used
   * encoding and the rotation policy.
   *
   * @schema CertificateSpec#privateKey
   */
  readonly privateKey?: CertificateSpecPrivateKey;

  /**
   * How long before the currently issued certificate's expiry cert-manager should
   * renew the certificate. For example, if a certificate is valid for 60 minutes,
   * and `renewBefore=10m`, cert-manager will begin to attempt to renew the certificate
   * 50 minutes after it was issued (i.e. when there are 10 minutes remaining until
   * the certificate is no longer valid).
   *
   * NOTE: The actual lifetime of the issued certificate is used to determine the
   * renewal time. If an issuer returns a certificate with a different lifetime than
   * the one requested, cert-manager will use the lifetime of the issued certificate.
   *
   * If unset, this defaults to 1/3 of the issued certificate's lifetime.
   * Minimum accepted value is 5 minutes.
   * Value must be in units accepted by Go time.ParseDuration https://golang.org/pkg/time/#ParseDuration.
   * Cannot be set if the `renewBeforePercentage` field is set.
   *
   * @schema CertificateSpec#renewBefore
   */
  readonly renewBefore?: string;

  /**
   * `renewBeforePercentage` is like `renewBefore`, except it is a relative percentage
   * rather than an absolute duration. For example, if a certificate is valid for 60
   * minutes, and  `renewBeforePercentage=25`, cert-manager will begin to attempt to
   * renew the certificate 45 minutes after it was issued (i.e. when there are 15
   * minutes (25%) remaining until the certificate is no longer valid).
   *
   * NOTE: The actual lifetime of the issued certificate is used to determine the
   * renewal time. If an issuer returns a certificate with a different lifetime than
   * the one requested, cert-manager will use the lifetime of the issued certificate.
   *
   * Value must be an integer in the range (0,100). The minimum effective
   * `renewBefore` derived from the `renewBeforePercentage` and `duration` fields is 5
   * minutes.
   * Cannot be set if the `renewBefore` field is set.
   *
   * @schema CertificateSpec#renewBeforePercentage
   */
  readonly renewBeforePercentage?: number;

  /**
   * The maximum number of CertificateRequest revisions that are maintained in
   * the Certificate's history. Each revision represents a single `CertificateRequest`
   * created by this Certificate, either when it was created, renewed, or Spec
   * was changed. Revisions will be removed by oldest first if the number of
   * revisions exceeds this number.
   *
   * If set, revisionHistoryLimit must be a value of `1` or greater.
   * If unset (`nil`), revisions will not be garbage collected.
   * Default value is `nil`.
   *
   * @schema CertificateSpec#revisionHistoryLimit
   */
  readonly revisionHistoryLimit?: number;

  /**
   * Name of the Secret resource that will be automatically created and
   * managed by this Certificate resource. It will be populated with a
   * private key and certificate, signed by the denoted issuer. The Secret
   * resource lives in the same namespace as the Certificate resource.
   *
   * @schema CertificateSpec#secretName
   */
  readonly secretName: string;

  /**
   * Defines annotations and labels to be copied to the Certificate's Secret.
   * Labels and annotations on the Secret will be changed as they appear on the
   * SecretTemplate when added or removed. SecretTemplate annotations are added
   * in conjunction with, and cannot overwrite, the base set of annotations
   * cert-manager sets on the Certificate's Secret.
   *
   * @schema CertificateSpec#secretTemplate
   */
  readonly secretTemplate?: CertificateSpecSecretTemplate;

  /**
   * Signature algorith to use.
   * Allowed values for RSA keys: SHA256WithRSA, SHA384WithRSA, SHA512WithRSA.
   * Allowed values for ECDSA keys: ECDSAWithSHA256, ECDSAWithSHA384, ECDSAWithSHA512.
   * Allowed values for Ed25519 keys: PureEd25519.
   *
   * @schema CertificateSpec#signatureAlgorithm
   */
  readonly signatureAlgorithm?: CertificateSpecSignatureAlgorithm;

  /**
   * Requested set of X509 certificate subject attributes.
   * More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6
   *
   * The common name attribute is specified separately in the `commonName` field.
   * Cannot be set if the `literalSubject` field is set.
   *
   * @schema CertificateSpec#subject
   */
  readonly subject?: CertificateSpecSubject;

  /**
   * Requested URI subject alternative names.
   *
   * @schema CertificateSpec#uris
   */
  readonly uris?: string[];

  /**
   * Requested key usages and extended key usages.
   * These usages are used to set the `usages` field on the created CertificateRequest
   * resources. If `encodeUsagesInRequest` is unset or set to `true`, the usages
   * will additionally be encoded in the `request` field which contains the CSR blob.
   *
   * If unset, defaults to `digital signature` and `key encipherment`.
   *
   * @schema CertificateSpec#usages
   */
  readonly usages?: CertificateSpecUsages[];

}

/**
 * Converts an object of type 'CertificateSpec' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpec(obj: CertificateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalOutputFormats': obj.additionalOutputFormats?.map(y => toJson_CertificateSpecAdditionalOutputFormats(y)),
    'commonName': obj.commonName,
    'dnsNames': obj.dnsNames?.map(y => y),
    'duration': obj.duration,
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'encodeUsagesInRequest': obj.encodeUsagesInRequest,
    'ipAddresses': obj.ipAddresses?.map(y => y),
    'isCA': obj.isCa,
    'issuerRef': toJson_CertificateSpecIssuerRef(obj.issuerRef),
    'keystores': toJson_CertificateSpecKeystores(obj.keystores),
    'literalSubject': obj.literalSubject,
    'nameConstraints': toJson_CertificateSpecNameConstraints(obj.nameConstraints),
    'otherNames': obj.otherNames?.map(y => toJson_CertificateSpecOtherNames(y)),
    'privateKey': toJson_CertificateSpecPrivateKey(obj.privateKey),
    'renewBefore': obj.renewBefore,
    'renewBeforePercentage': obj.renewBeforePercentage,
    'revisionHistoryLimit': obj.revisionHistoryLimit,
    'secretName': obj.secretName,
    'secretTemplate': toJson_CertificateSpecSecretTemplate(obj.secretTemplate),
    'signatureAlgorithm': obj.signatureAlgorithm,
    'subject': toJson_CertificateSpecSubject(obj.subject),
    'uris': obj.uris?.map(y => y),
    'usages': obj.usages?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * CertificateAdditionalOutputFormat defines an additional output format of a
 * Certificate resource. These contain supplementary data formats of the signed
 * certificate chain and paired private key.
 *
 * @schema CertificateSpecAdditionalOutputFormats
 */
export interface CertificateSpecAdditionalOutputFormats {
  /**
   * Type is the name of the format type that should be written to the
   * Certificate's target Secret.
   *
   * @schema CertificateSpecAdditionalOutputFormats#type
   */
  readonly type: CertificateSpecAdditionalOutputFormatsType;

}

/**
 * Converts an object of type 'CertificateSpecAdditionalOutputFormats' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecAdditionalOutputFormats(obj: CertificateSpecAdditionalOutputFormats | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Reference to the issuer responsible for issuing the certificate.
 * If the issuer is namespace-scoped, it must be in the same namespace
 * as the Certificate. If the issuer is cluster-scoped, it can be used
 * from any namespace.
 *
 * The `name` field of the reference must always be specified.
 *
 * @schema CertificateSpecIssuerRef
 */
export interface CertificateSpecIssuerRef {
  /**
   * Group of the resource being referred to.
   *
   * @schema CertificateSpecIssuerRef#group
   */
  readonly group?: string;

  /**
   * Kind of the resource being referred to.
   *
   * @schema CertificateSpecIssuerRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the resource being referred to.
   *
   * @schema CertificateSpecIssuerRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecIssuerRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecIssuerRef(obj: CertificateSpecIssuerRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'group': obj.group,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Additional keystore output formats to be stored in the Certificate's Secret.
 *
 * @schema CertificateSpecKeystores
 */
export interface CertificateSpecKeystores {
  /**
   * JKS configures options for storing a JKS keystore in the
   * `spec.secretName` Secret resource.
   *
   * @schema CertificateSpecKeystores#jks
   */
  readonly jks?: CertificateSpecKeystoresJks;

  /**
   * PKCS12 configures options for storing a PKCS12 keystore in the
   * `spec.secretName` Secret resource.
   *
   * @schema CertificateSpecKeystores#pkcs12
   */
  readonly pkcs12?: CertificateSpecKeystoresPkcs12;

}

/**
 * Converts an object of type 'CertificateSpecKeystores' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecKeystores(obj: CertificateSpecKeystores | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jks': toJson_CertificateSpecKeystoresJks(obj.jks),
    'pkcs12': toJson_CertificateSpecKeystoresPkcs12(obj.pkcs12),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * x.509 certificate NameConstraint extension which MUST NOT be used in a non-CA certificate.
 * More Info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.10
 *
 * This is an Alpha Feature and is only enabled with the
 * `--feature-gates=NameConstraints=true` option set on both
 * the controller and webhook components.
 *
 * @schema CertificateSpecNameConstraints
 */
export interface CertificateSpecNameConstraints {
  /**
   * if true then the name constraints are marked critical.
   *
   * @schema CertificateSpecNameConstraints#critical
   */
  readonly critical?: boolean;

  /**
   * Excluded contains the constraints which must be disallowed. Any name matching a
   * restriction in the excluded field is invalid regardless
   * of information appearing in the permitted
   *
   * @schema CertificateSpecNameConstraints#excluded
   */
  readonly excluded?: CertificateSpecNameConstraintsExcluded;

  /**
   * Permitted contains the constraints in which the names must be located.
   *
   * @schema CertificateSpecNameConstraints#permitted
   */
  readonly permitted?: CertificateSpecNameConstraintsPermitted;

}

/**
 * Converts an object of type 'CertificateSpecNameConstraints' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecNameConstraints(obj: CertificateSpecNameConstraints | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'critical': obj.critical,
    'excluded': toJson_CertificateSpecNameConstraintsExcluded(obj.excluded),
    'permitted': toJson_CertificateSpecNameConstraintsPermitted(obj.permitted),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * @schema CertificateSpecOtherNames
 */
export interface CertificateSpecOtherNames {
  /**
   * OID is the object identifier for the otherName SAN.
   * The object identifier must be expressed as a dotted string, for
   * example, "1.2.840.113556.1.4.221".
   *
   * @schema CertificateSpecOtherNames#oid
   */
  readonly oid?: string;

  /**
   * utf8Value is the string value of the otherName SAN.
   * The utf8Value accepts any valid UTF8 string to set as value for the otherName SAN.
   *
   * @schema CertificateSpecOtherNames#utf8Value
   */
  readonly utf8Value?: string;

}

/**
 * Converts an object of type 'CertificateSpecOtherNames' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecOtherNames(obj: CertificateSpecOtherNames | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oid': obj.oid,
    'utf8Value': obj.utf8Value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Private key options. These include the key algorithm and size, the used
 * encoding and the rotation policy.
 *
 * @schema CertificateSpecPrivateKey
 */
export interface CertificateSpecPrivateKey {
  /**
   * Algorithm is the private key algorithm of the corresponding private key
   * for this certificate.
   *
   * If provided, allowed values are either `RSA`, `ECDSA` or `Ed25519`.
   * If `algorithm` is specified and `size` is not provided,
   * key size of 2048 will be used for `RSA` key algorithm and
   * key size of 256 will be used for `ECDSA` key algorithm.
   * key size is ignored when using the `Ed25519` key algorithm.
   *
   * @schema CertificateSpecPrivateKey#algorithm
   */
  readonly algorithm?: CertificateSpecPrivateKeyAlgorithm;

  /**
   * The private key cryptography standards (PKCS) encoding for this
   * certificate's private key to be encoded in.
   *
   * If provided, allowed values are `PKCS1` and `PKCS8` standing for PKCS#1
   * and PKCS#8, respectively.
   * Defaults to `PKCS1` if not specified.
   *
   * @default PKCS1` if not specified.
   * @schema CertificateSpecPrivateKey#encoding
   */
  readonly encoding?: CertificateSpecPrivateKeyEncoding;

  /**
   * RotationPolicy controls how private keys should be regenerated when a
   * re-issuance is being processed.
   *
   * If set to `Never`, a private key will only be generated if one does not
   * already exist in the target `spec.secretName`. If one does exist but it
   * does not have the correct algorithm or size, a warning will be raised
   * to await user intervention.
   * If set to `Always`, a private key matching the specified requirements
   * will be generated whenever a re-issuance occurs.
   * Default is `Never` for backward compatibility.
   *
   * @default Never` for backward compatibility.
   * @schema CertificateSpecPrivateKey#rotationPolicy
   */
  readonly rotationPolicy?: CertificateSpecPrivateKeyRotationPolicy;

  /**
   * Size is the key bit size of the corresponding private key for this certificate.
   *
   * If `algorithm` is set to `RSA`, valid values are `2048`, `4096` or `8192`,
   * and will default to `2048` if not specified.
   * If `algorithm` is set to `ECDSA`, valid values are `256`, `384` or `521`,
   * and will default to `256` if not specified.
   * If `algorithm` is set to `Ed25519`, Size is ignored.
   * No other values are allowed.
   *
   * @schema CertificateSpecPrivateKey#size
   */
  readonly size?: number;

}

/**
 * Converts an object of type 'CertificateSpecPrivateKey' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecPrivateKey(obj: CertificateSpecPrivateKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'algorithm': obj.algorithm,
    'encoding': obj.encoding,
    'rotationPolicy': obj.rotationPolicy,
    'size': obj.size,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Defines annotations and labels to be copied to the Certificate's Secret.
 * Labels and annotations on the Secret will be changed as they appear on the
 * SecretTemplate when added or removed. SecretTemplate annotations are added
 * in conjunction with, and cannot overwrite, the base set of annotations
 * cert-manager sets on the Certificate's Secret.
 *
 * @schema CertificateSpecSecretTemplate
 */
export interface CertificateSpecSecretTemplate {
  /**
   * Annotations is a key value map to be copied to the target Kubernetes Secret.
   *
   * @schema CertificateSpecSecretTemplate#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Labels is a key value map to be copied to the target Kubernetes Secret.
   *
   * @schema CertificateSpecSecretTemplate#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'CertificateSpecSecretTemplate' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecSecretTemplate(obj: CertificateSpecSecretTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Signature algorith to use.
 * Allowed values for RSA keys: SHA256WithRSA, SHA384WithRSA, SHA512WithRSA.
 * Allowed values for ECDSA keys: ECDSAWithSHA256, ECDSAWithSHA384, ECDSAWithSHA512.
 * Allowed values for Ed25519 keys: PureEd25519.
 *
 * @schema CertificateSpecSignatureAlgorithm
 */
export enum CertificateSpecSignatureAlgorithm {
  /** SHA256WithRSA */
  SHA256_WITH_RSA = "SHA256WithRSA",
  /** SHA384WithRSA */
  SHA384_WITH_RSA = "SHA384WithRSA",
  /** SHA512WithRSA */
  SHA512_WITH_RSA = "SHA512WithRSA",
  /** ECDSAWithSHA256 */
  ECDSA_WITH_SHA256 = "ECDSAWithSHA256",
  /** ECDSAWithSHA384 */
  ECDSA_WITH_SHA384 = "ECDSAWithSHA384",
  /** ECDSAWithSHA512 */
  ECDSA_WITH_SHA512 = "ECDSAWithSHA512",
  /** PureEd25519 */
  PURE_ED25519 = "PureEd25519",
}

/**
 * Requested set of X509 certificate subject attributes.
 * More info: https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.6
 *
 * The common name attribute is specified separately in the `commonName` field.
 * Cannot be set if the `literalSubject` field is set.
 *
 * @schema CertificateSpecSubject
 */
export interface CertificateSpecSubject {
  /**
   * Countries to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#countries
   */
  readonly countries?: string[];

  /**
   * Cities to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#localities
   */
  readonly localities?: string[];

  /**
   * Organizational Units to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#organizationalUnits
   */
  readonly organizationalUnits?: string[];

  /**
   * Organizations to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#organizations
   */
  readonly organizations?: string[];

  /**
   * Postal codes to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#postalCodes
   */
  readonly postalCodes?: string[];

  /**
   * State/Provinces to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#provinces
   */
  readonly provinces?: string[];

  /**
   * Serial number to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#serialNumber
   */
  readonly serialNumber?: string;

  /**
   * Street addresses to be used on the Certificate.
   *
   * @schema CertificateSpecSubject#streetAddresses
   */
  readonly streetAddresses?: string[];

}

/**
 * Converts an object of type 'CertificateSpecSubject' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecSubject(obj: CertificateSpecSubject | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'countries': obj.countries?.map(y => y),
    'localities': obj.localities?.map(y => y),
    'organizationalUnits': obj.organizationalUnits?.map(y => y),
    'organizations': obj.organizations?.map(y => y),
    'postalCodes': obj.postalCodes?.map(y => y),
    'provinces': obj.provinces?.map(y => y),
    'serialNumber': obj.serialNumber,
    'streetAddresses': obj.streetAddresses?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * KeyUsage specifies valid usage contexts for keys.
 * See:
 * https://tools.ietf.org/html/rfc5280#section-4.2.1.3
 * https://tools.ietf.org/html/rfc5280#section-4.2.1.12
 *
 * Valid KeyUsage values are as follows:
 * "signing",
 * "digital signature",
 * "content commitment",
 * "key encipherment",
 * "key agreement",
 * "data encipherment",
 * "cert sign",
 * "crl sign",
 * "encipher only",
 * "decipher only",
 * "any",
 * "server auth",
 * "client auth",
 * "code signing",
 * "email protection",
 * "s/mime",
 * "ipsec end system",
 * "ipsec tunnel",
 * "ipsec user",
 * "timestamping",
 * "ocsp signing",
 * "microsoft sgc",
 * "netscape sgc"
 *
 * @schema CertificateSpecUsages
 */
export enum CertificateSpecUsages {
  /** signing */
  SIGNING = "signing",
  /** digital signature */
  DIGITAL_SIGNATURE = "digital signature",
  /** content commitment */
  CONTENT_COMMITMENT = "content commitment",
  /** key encipherment */
  KEY_ENCIPHERMENT = "key encipherment",
  /** key agreement */
  KEY_AGREEMENT = "key agreement",
  /** data encipherment */
  DATA_ENCIPHERMENT = "data encipherment",
  /** cert sign */
  CERT_SIGN = "cert sign",
  /** crl sign */
  CRL_SIGN = "crl sign",
  /** encipher only */
  ENCIPHER_ONLY = "encipher only",
  /** decipher only */
  DECIPHER_ONLY = "decipher only",
  /** any */
  ANY = "any",
  /** server auth */
  SERVER_AUTH = "server auth",
  /** client auth */
  CLIENT_AUTH = "client auth",
  /** code signing */
  CODE_SIGNING = "code signing",
  /** email protection */
  EMAIL_PROTECTION = "email protection",
  /** s/mime */
  S_MIME = "s/mime",
  /** ipsec end system */
  IPSEC_END_SYSTEM = "ipsec end system",
  /** ipsec tunnel */
  IPSEC_TUNNEL = "ipsec tunnel",
  /** ipsec user */
  IPSEC_USER = "ipsec user",
  /** timestamping */
  TIMESTAMPING = "timestamping",
  /** ocsp signing */
  OCSP_SIGNING = "ocsp signing",
  /** microsoft sgc */
  MICROSOFT_SGC = "microsoft sgc",
  /** netscape sgc */
  NETSCAPE_SGC = "netscape sgc",
}

/**
 * Type is the name of the format type that should be written to the
 * Certificate's target Secret.
 *
 * @schema CertificateSpecAdditionalOutputFormatsType
 */
export enum CertificateSpecAdditionalOutputFormatsType {
  /** DER */
  DER = "DER",
  /** CombinedPEM */
  COMBINED_PEM = "CombinedPEM",
}

/**
 * JKS configures options for storing a JKS keystore in the
 * `spec.secretName` Secret resource.
 *
 * @schema CertificateSpecKeystoresJks
 */
export interface CertificateSpecKeystoresJks {
  /**
   * Alias specifies the alias of the key in the keystore, required by the JKS format.
   * If not provided, the default alias `certificate` will be used.
   *
   * @schema CertificateSpecKeystoresJks#alias
   */
  readonly alias?: string;

  /**
   * Create enables JKS keystore creation for the Certificate.
   * If true, a file named `keystore.jks` will be created in the target
   * Secret resource, encrypted using the password stored in
   * `passwordSecretRef` or `password`.
   * The keystore file will be updated immediately.
   * If the issuer provided a CA certificate, a file named `truststore.jks`
   * will also be created in the target Secret resource, encrypted using the
   * password stored in `passwordSecretRef`
   * containing the issuing Certificate Authority
   *
   * @schema CertificateSpecKeystoresJks#create
   */
  readonly create: boolean;

  /**
   * Password provides a literal password used to encrypt the JKS keystore.
   * Mutually exclusive with passwordSecretRef.
   * One of password or passwordSecretRef must provide a password with a non-zero length.
   *
   * @schema CertificateSpecKeystoresJks#password
   */
  readonly password?: string;

  /**
   * PasswordSecretRef is a reference to a non-empty key in a Secret resource
   * containing the password used to encrypt the JKS keystore.
   * Mutually exclusive with password.
   * One of password or passwordSecretRef must provide a password with a non-zero length.
   *
   * @schema CertificateSpecKeystoresJks#passwordSecretRef
   */
  readonly passwordSecretRef?: CertificateSpecKeystoresJksPasswordSecretRef;

}

/**
 * Converts an object of type 'CertificateSpecKeystoresJks' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecKeystoresJks(obj: CertificateSpecKeystoresJks | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'alias': obj.alias,
    'create': obj.create,
    'password': obj.password,
    'passwordSecretRef': toJson_CertificateSpecKeystoresJksPasswordSecretRef(obj.passwordSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PKCS12 configures options for storing a PKCS12 keystore in the
 * `spec.secretName` Secret resource.
 *
 * @schema CertificateSpecKeystoresPkcs12
 */
export interface CertificateSpecKeystoresPkcs12 {
  /**
   * Create enables PKCS12 keystore creation for the Certificate.
   * If true, a file named `keystore.p12` will be created in the target
   * Secret resource, encrypted using the password stored in
   * `passwordSecretRef` or in `password`.
   * The keystore file will be updated immediately.
   * If the issuer provided a CA certificate, a file named `truststore.p12` will
   * also be created in the target Secret resource, encrypted using the
   * password stored in `passwordSecretRef` containing the issuing Certificate
   * Authority
   *
   * @schema CertificateSpecKeystoresPkcs12#create
   */
  readonly create: boolean;

  /**
   * Password provides a literal password used to encrypt the PKCS#12 keystore.
   * Mutually exclusive with passwordSecretRef.
   * One of password or passwordSecretRef must provide a password with a non-zero length.
   *
   * @schema CertificateSpecKeystoresPkcs12#password
   */
  readonly password?: string;

  /**
   * PasswordSecretRef is a reference to a non-empty key in a Secret resource
   * containing the password used to encrypt the PKCS#12 keystore.
   * Mutually exclusive with password.
   * One of password or passwordSecretRef must provide a password with a non-zero length.
   *
   * @schema CertificateSpecKeystoresPkcs12#passwordSecretRef
   */
  readonly passwordSecretRef?: CertificateSpecKeystoresPkcs12PasswordSecretRef;

  /**
   * Profile specifies the key and certificate encryption algorithms and the HMAC algorithm
   * used to create the PKCS12 keystore. Default value is `LegacyRC2` for backward compatibility.
   *
   * If provided, allowed values are:
   * `LegacyRC2`: Deprecated. Not supported by default in OpenSSL 3 or Java 20.
   * `LegacyDES`: Less secure algorithm. Use this option for maximal compatibility.
   * `Modern2023`: Secure algorithm. Use this option in case you have to always use secure algorithms
   * (eg. because of company policy). Please note that the security of the algorithm is not that important
   * in reality, because the unencrypted certificate and private key are also stored in the Secret.
   *
   * @schema CertificateSpecKeystoresPkcs12#profile
   */
  readonly profile?: CertificateSpecKeystoresPkcs12Profile;

}

/**
 * Converts an object of type 'CertificateSpecKeystoresPkcs12' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecKeystoresPkcs12(obj: CertificateSpecKeystoresPkcs12 | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'create': obj.create,
    'password': obj.password,
    'passwordSecretRef': toJson_CertificateSpecKeystoresPkcs12PasswordSecretRef(obj.passwordSecretRef),
    'profile': obj.profile,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Excluded contains the constraints which must be disallowed. Any name matching a
 * restriction in the excluded field is invalid regardless
 * of information appearing in the permitted
 *
 * @schema CertificateSpecNameConstraintsExcluded
 */
export interface CertificateSpecNameConstraintsExcluded {
  /**
   * DNSDomains is a list of DNS domains that are permitted or excluded.
   *
   * @schema CertificateSpecNameConstraintsExcluded#dnsDomains
   */
  readonly dnsDomains?: string[];

  /**
   * EmailAddresses is a list of Email Addresses that are permitted or excluded.
   *
   * @schema CertificateSpecNameConstraintsExcluded#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * IPRanges is a list of IP Ranges that are permitted or excluded.
   * This should be a valid CIDR notation.
   *
   * @schema CertificateSpecNameConstraintsExcluded#ipRanges
   */
  readonly ipRanges?: string[];

  /**
   * URIDomains is a list of URI domains that are permitted or excluded.
   *
   * @schema CertificateSpecNameConstraintsExcluded#uriDomains
   */
  readonly uriDomains?: string[];

}

/**
 * Converts an object of type 'CertificateSpecNameConstraintsExcluded' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecNameConstraintsExcluded(obj: CertificateSpecNameConstraintsExcluded | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsDomains': obj.dnsDomains?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipRanges': obj.ipRanges?.map(y => y),
    'uriDomains': obj.uriDomains?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Permitted contains the constraints in which the names must be located.
 *
 * @schema CertificateSpecNameConstraintsPermitted
 */
export interface CertificateSpecNameConstraintsPermitted {
  /**
   * DNSDomains is a list of DNS domains that are permitted or excluded.
   *
   * @schema CertificateSpecNameConstraintsPermitted#dnsDomains
   */
  readonly dnsDomains?: string[];

  /**
   * EmailAddresses is a list of Email Addresses that are permitted or excluded.
   *
   * @schema CertificateSpecNameConstraintsPermitted#emailAddresses
   */
  readonly emailAddresses?: string[];

  /**
   * IPRanges is a list of IP Ranges that are permitted or excluded.
   * This should be a valid CIDR notation.
   *
   * @schema CertificateSpecNameConstraintsPermitted#ipRanges
   */
  readonly ipRanges?: string[];

  /**
   * URIDomains is a list of URI domains that are permitted or excluded.
   *
   * @schema CertificateSpecNameConstraintsPermitted#uriDomains
   */
  readonly uriDomains?: string[];

}

/**
 * Converts an object of type 'CertificateSpecNameConstraintsPermitted' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecNameConstraintsPermitted(obj: CertificateSpecNameConstraintsPermitted | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dnsDomains': obj.dnsDomains?.map(y => y),
    'emailAddresses': obj.emailAddresses?.map(y => y),
    'ipRanges': obj.ipRanges?.map(y => y),
    'uriDomains': obj.uriDomains?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Algorithm is the private key algorithm of the corresponding private key
 * for this certificate.
 *
 * If provided, allowed values are either `RSA`, `ECDSA` or `Ed25519`.
 * If `algorithm` is specified and `size` is not provided,
 * key size of 2048 will be used for `RSA` key algorithm and
 * key size of 256 will be used for `ECDSA` key algorithm.
 * key size is ignored when using the `Ed25519` key algorithm.
 *
 * @schema CertificateSpecPrivateKeyAlgorithm
 */
export enum CertificateSpecPrivateKeyAlgorithm {
  /** RSA */
  RSA = "RSA",
  /** ECDSA */
  ECDSA = "ECDSA",
  /** Ed25519 */
  ED25519 = "Ed25519",
}

/**
 * The private key cryptography standards (PKCS) encoding for this
 * certificate's private key to be encoded in.
 *
 * If provided, allowed values are `PKCS1` and `PKCS8` standing for PKCS#1
 * and PKCS#8, respectively.
 * Defaults to `PKCS1` if not specified.
 *
 * @default PKCS1` if not specified.
 * @schema CertificateSpecPrivateKeyEncoding
 */
export enum CertificateSpecPrivateKeyEncoding {
  /** PKCS1 */
  PKCS1 = "PKCS1",
  /** PKCS8 */
  PKCS8 = "PKCS8",
}

/**
 * RotationPolicy controls how private keys should be regenerated when a
 * re-issuance is being processed.
 *
 * If set to `Never`, a private key will only be generated if one does not
 * already exist in the target `spec.secretName`. If one does exist but it
 * does not have the correct algorithm or size, a warning will be raised
 * to await user intervention.
 * If set to `Always`, a private key matching the specified requirements
 * will be generated whenever a re-issuance occurs.
 * Default is `Never` for backward compatibility.
 *
 * @default Never` for backward compatibility.
 * @schema CertificateSpecPrivateKeyRotationPolicy
 */
export enum CertificateSpecPrivateKeyRotationPolicy {
  /** Never */
  NEVER = "Never",
  /** Always */
  ALWAYS = "Always",
}

/**
 * PasswordSecretRef is a reference to a non-empty key in a Secret resource
 * containing the password used to encrypt the JKS keystore.
 * Mutually exclusive with password.
 * One of password or passwordSecretRef must provide a password with a non-zero length.
 *
 * @schema CertificateSpecKeystoresJksPasswordSecretRef
 */
export interface CertificateSpecKeystoresJksPasswordSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema CertificateSpecKeystoresJksPasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema CertificateSpecKeystoresJksPasswordSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecKeystoresJksPasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecKeystoresJksPasswordSecretRef(obj: CertificateSpecKeystoresJksPasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * PasswordSecretRef is a reference to a non-empty key in a Secret resource
 * containing the password used to encrypt the PKCS#12 keystore.
 * Mutually exclusive with password.
 * One of password or passwordSecretRef must provide a password with a non-zero length.
 *
 * @schema CertificateSpecKeystoresPkcs12PasswordSecretRef
 */
export interface CertificateSpecKeystoresPkcs12PasswordSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used.
   * Some instances of this field may be defaulted, in others it may be
   * required.
   *
   * @schema CertificateSpecKeystoresPkcs12PasswordSecretRef#key
   */
  readonly key?: string;

  /**
   * Name of the resource being referred to.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema CertificateSpecKeystoresPkcs12PasswordSecretRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'CertificateSpecKeystoresPkcs12PasswordSecretRef' to JSON representation.
 */
/* eslint-disable max-len, quote-props */
export function toJson_CertificateSpecKeystoresPkcs12PasswordSecretRef(obj: CertificateSpecKeystoresPkcs12PasswordSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, quote-props */

/**
 * Profile specifies the key and certificate encryption algorithms and the HMAC algorithm
 * used to create the PKCS12 keystore. Default value is `LegacyRC2` for backward compatibility.
 *
 * If provided, allowed values are:
 * `LegacyRC2`: Deprecated. Not supported by default in OpenSSL 3 or Java 20.
 * `LegacyDES`: Less secure algorithm. Use this option for maximal compatibility.
 * `Modern2023`: Secure algorithm. Use this option in case you have to always use secure algorithms
 * (eg. because of company policy). Please note that the security of the algorithm is not that important
 * in reality, because the unencrypted certificate and private key are also stored in the Secret.
 *
 * @schema CertificateSpecKeystoresPkcs12Profile
 */
export enum CertificateSpecKeystoresPkcs12Profile {
  /** LegacyRC2 */
  LEGACY_RC2 = "LegacyRC2",
  /** LegacyDES */
  LEGACY_DES = "LegacyDES",
  /** Modern2023 */
  MODERN2023 = "Modern2023",
}

